'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.eventTypes = exports.EventCalendar = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _reactResizeDetector = require('react-resize-detector');

var _reactResizeDetector2 = _interopRequireDefault(_reactResizeDetector);

var _calendar = require('../components/calendar');

var _calendar2 = _interopRequireDefault(_calendar);

var _strings = require('../resources/values/strings');

var _utilities = require('../resources/utilities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Calendar = function (_Component) {
    _inherits(Calendar, _Component);

    function Calendar(props) {
        _classCallCheck(this, Calendar);

        var _this = _possibleConstructorReturn(this, (Calendar.__proto__ || Object.getPrototypeOf(Calendar)).call(this, props));

        _this.state = {
            calendarList: null,
            isLoading: true,
            month: 0,
            year: 0,
            numDaysInMonth: 0,
            isMobile: false,
            frameRef: _react2.default.createRef()
        };

        _this.initCalendarList = _this.initCalendarList.bind(_this);
        _this.loadEvent = _this.loadEvent.bind(_this);
        _this.loadCalendarList = _this.loadCalendarList.bind(_this);
        return _this;
    }

    /*
     * Load events and config props from the parent component. Events here are copied so that when we determine the
     * event type in the loadCalendarList function, we do not mutate the passed events which may have other uses in
     * their program.
     *
     * parseConfig checks for missing data members such as colors or weekdays, and injects default values for those
     * fields into the config object. This ensures calendar events will always be colored.
     */


    _createClass(Calendar, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _this2 = this;

            var _props = this.props,
                items = _props.items,
                config = _props.config,
                month = _props.month,
                year = _props.year;

            // Create deep copy so that user input is not mutated.

            var eventsCopy = JSON.parse(JSON.stringify(items));

            // Inject defaults if key is not overwritten.
            (0, _utilities.parseConfig)(config);

            var safeMonth = month ? month : new Date().getMonth() + 1;
            var safeYear = year ? year : new Date().getFullYear();

            this.initCalendarList(safeMonth, safeYear, function () {
                _this2.loadCalendarList(eventsCopy, safeMonth, safeYear);
            });
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps, nextContext) {
            var _this3 = this;

            if ((nextProps.month !== this.props.month || nextProps.year !== this.props.year) && nextProps.items) {
                var items = nextProps.items,
                    config = nextProps.config,
                    month = nextProps.month,
                    year = nextProps.year;

                // Create deep copy so that user input is not mutated.

                var eventsCopy = JSON.parse(JSON.stringify(items));

                // Inject defaults if key is not overwritten.
                (0, _utilities.parseConfig)(config);

                var safeMonth = month ? month : new Date().getMonth() + 1;
                var safeYear = year ? year : new Date().getFullYear();

                this.initCalendarList(safeMonth, safeYear, function () {
                    _this3.loadCalendarList(eventsCopy, safeMonth, safeYear);
                });
            }
        }

        /*
         * Initialize empty calendar list of a given length. This step is important because it allows us to use unshift
         * functions to load our events without worrying about the calendar index being undefined.
         *
         * This is the starting point of the calendar, and everything flows from here.
         * initCalendarList -> loadCalendarList -> loadEvent -> calendarList passed to presentational components and displayed.
         *
         * @param callBack: This callBack is the loadCalendarList function. Once the calendar has been initialized,
         *                  we can begin loading it.
         */

    }, {
        key: 'initCalendarList',
        value: function initCalendarList(month, year, callBack) {
            var numDaysInMonth = [31, year % 4 === 0 ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            var calendarList = [];

            var numDays = numDaysInMonth[month - 1];
            var offset = (0, _moment2.default)(year + '-' + month + '-01', 'YYYY-M-DD').day();
            var numTiles = offset + numDays > 35 ? 35 + 7 : 35;

            for (var i = 0; i < numTiles; i++) {
                calendarList[i] = [];
            }

            this.setState({ calendarList: calendarList, numDaysInMonth: numDaysInMonth }, function () {
                return callBack();
            });
        }

        /* Sort and iterate over copied events, assigning types and determining their place on the calendar.
         * numDays, offset, and most of the variables below are used to calculate the event's position from it's start
         * and end dates.
         */

    }, {
        key: 'loadCalendarList',
        value: function loadCalendarList(events, month, year) {
            var _this4 = this;

            // Six weeks, four weeks = selected month, one week for months before and after - 42 days total.
            // Group events on the same day, each element in array represents one day.
            var _state = this.state,
                calendarList = _state.calendarList,
                numDaysInMonth = _state.numDaysInMonth;
            var config = this.props.config;


            if (!config) return null;

            var firstDateStart = null,
                firstDateEnd = null;
            var secondDateStart = null,
                secondDateEnd = null;
            var firstDateCreated = null,
                secondDateCreated = null;

            var numDays = numDaysInMonth[month - 1];
            var numDaysInLastMonth = numDaysInMonth[month - 2 >= 0 ? month - 2 : 11];
            var numDaysInNextMonth = numDaysInMonth[month > 11 ? 0 : month];
            var offset = (0, _moment2.default)(year + '-' + month + '-01', "YYYY-M-DD").day();
            var numTiles = offset + numDays > 35 ? 35 + 7 : 35;

            var argsObject = { numDays: numDays, numDaysInMonth: numDaysInMonth, numDaysInLastMonth: numDaysInLastMonth, numDaysInNextMonth: numDaysInNextMonth, offset: offset, month: month, year: year, numTiles: numTiles };

            events.sort(function (firstEvent, secondEvent) {

                firstDateCreated = (0, _moment2.default)(firstEvent.created);
                secondDateCreated = (0, _moment2.default)(secondEvent.created);

                firstDateStart = (0, _moment2.default)(firstEvent.start, config.dateFormat);
                firstDateEnd = (0, _moment2.default)(firstEvent.end, config.dateFormat);

                secondDateStart = (0, _moment2.default)(secondEvent.start, config.dateFormat);
                secondDateEnd = (0, _moment2.default)(secondEvent.end, config.dateFormat);

                var args = {
                    firstDateStart: firstDateStart,
                    firstDateEnd: firstDateEnd,
                    secondDateStart: secondDateStart,
                    secondDateEnd: secondDateEnd,
                    month: month,
                    numDaysInMonth: numDaysInMonth
                };

                return (0, _utilities.computeDifferences)(firstDateCreated, secondDateCreated, firstEvent, secondEvent, args);
            });

            events.map(function (event) {
                var _parseEvent = (0, _utilities.parseEvent)(event, argsObject, config),
                    parsedDay = _parseEvent.parsedDay,
                    parsedEnd = _parseEvent.parsedEnd,
                    parsedMonth = _parseEvent.parsedMonth,
                    parsedMonthEnd = _parseEvent.parsedMonthEnd,
                    isBelowEventRange = _parseEvent.isBelowEventRange,
                    isAboveEventRange = _parseEvent.isAboveEventRange;

                var parts = {
                    numTiles: numTiles,
                    parsedDay: parsedDay,
                    parsedEnd: parsedEnd,
                    offset: offset,
                    month: month,
                    numDaysInLastMonth: numDaysInLastMonth,
                    numDays: numDays
                };

                if (!isBelowEventRange || !isAboveEventRange) {
                    for (var i = parsedDay, j = 0; i < parsedEnd; i++, j++) {
                        switch (true) {
                            // Event is multiple days long
                            case Math.abs(parsedEnd - parsedDay) > 1:
                                event.type = _strings.MULTI_DAY_TYPE;
                                break;

                            // Event takes place over a single day
                            case parsedMonth === parsedMonthEnd ? Math.abs(parsedEnd - parsedDay) <= 1 : Math.abs(parsedEnd - parsedDay - parsedDay) <= 1:
                                event.type = _strings.SINGLE_DAY_TYPE;
                                break;

                            // If event reaches here, there is likely something wrong with its structure.
                            // Set it as a placeholder so it is less likely to disrupt other events.
                            default:
                                event.type = _strings.PLACEHOLDER_TYPE;
                                break;
                        }

                        switch (true) {
                            // Event belongs to 'this' month
                            case parsedMonth === month:
                                _this4.loadEvent(event, calendarList, i + offset - 1, parts, j);
                                break;

                            // Event belongs to previous month
                            case parsedMonth === (month - 1 >= 1 ? month - 1 : 12):
                                _this4.loadEvent(event, calendarList, i - numDaysInLastMonth + offset - 1, parts, j);
                                break;

                            // Event belongs to next month
                            default:
                                _this4.loadEvent(event, calendarList, numDays + i + offset - 1, parts, j);
                                break;
                        }
                    }
                }

                return 0; // Get rid of warning
            });

            // Perform second pass to reorder placeholder events so that space can be saved.
            (0, _utilities.reorderEvents)({ calendarList: calendarList, numDays: numDays, numDaysInMonth: numDaysInMonth, numDaysInLastMonth: numDaysInLastMonth, numDaysInNextMonth: numDaysInNextMonth, offset: offset, month: month, year: year, numTiles: numTiles, config: config });

            this.setState({ calendarList: calendarList, isLoading: false, month: month, year: year });
        }

        /* Place event into appropriate spot on calendar, check for vertical overflow, and wrap events that extend past
         * calendar border.
         *
         * This is the last step before the calendarList is passed to the presentational components.
         */

    }, {
        key: 'loadEvent',
        value: function loadEvent(event, calendarList, i, parts, j) {
            var config = this.props.config;
            var parsedEnd = parts.parsedEnd,
                numTiles = parts.numTiles;

            var ranOnce = false;
            if (i >= 0 && i < numTiles && j === 0) {
                calendarList[i].unshift(event);

                (0, _utilities.wrapLongEvent)(event, ranOnce, calendarList, parts, i, event, config);
            } else {
                var start = (0, _moment2.default)(event.start, config.dateFormat);
                var end = (0, _moment2.default)(event.end, config.dateFormat);

                if (i >= 0 && i < numTiles) {
                    if (!_strings.wrappingTiles.includes(i - 1)) {
                        calendarList[i].unshift({
                            summary: event.summary,
                            created: event.created,
                            type: _strings.PLACEHOLDER_TYPE,
                            start: { date: start.year() + '-' + (start.month() + 1) + '-' + parsedEnd },
                            end: { date: end.year() + '-' + (end.month() + 1) + '-' + parsedEnd }
                        });
                    }
                }
            }
        }

        /* Calendar will shrink into mobile mode when the calendar's container is below a certain height or width.
         * Width and height values are determined to be the lowest values possible and still retain calendar integrity.
         */

    }, {
        key: 'checkParentDimensions',
        value: function checkParentDimensions(ref) {
            var width = ref.current.clientWidth;
            var height = ref.current.clientHeight;

            if (width < 451 || height < 521) {
                this.setState({
                    isMobile: true
                });
            } else {
                this.setState({
                    isMobile: false
                });
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this5 = this;

            var config = this.props.config;
            var _state2 = this.state,
                calendarList = _state2.calendarList,
                isLoading = _state2.isLoading,
                month = _state2.month,
                year = _state2.year,
                numDaysInMonth = _state2.numDaysInMonth,
                isMobile = _state2.isMobile,
                frameRef = _state2.frameRef;


            if (isLoading) {
                return _react2.default.createElement('div', null);
            }

            // Patch for leap years since year value is dynamic.
            config.numDaysInMonth = numDaysInMonth;
            config.isMobile = isMobile;

            return _react2.default.createElement(
                'div',
                { className: 'calendar-frame', ref: frameRef, style: { height: config.height, width: config.width } },
                _react2.default.createElement(_calendar2.default, { year: year, month: month, calendarList: calendarList, config: config }),
                _react2.default.createElement(_reactResizeDetector2.default, {
                    handleHeight: true,
                    handleWidth: true,
                    onResize: function onResize() {
                        return _this5.checkParentDimensions(frameRef);
                    },
                    refreshMode: 'debounce',
                    refreshRate: 200
                })
            );
        }
    }]);

    return Calendar;
}(_react.Component);

var EventCalendar = exports.EventCalendar = Calendar;
var eventTypes = exports.eventTypes = { PLACEHOLDER_TYPE: _strings.PLACEHOLDER_TYPE, MULTI_DAY_TYPE: _strings.MULTI_DAY_TYPE, SINGLE_DAY_TYPE: _strings.SINGLE_DAY_TYPE };
