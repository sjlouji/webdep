'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.computeDifferences = exports.wrapLongEvent = exports.parseConfig = exports.reorderEvents = exports.parseEvent = undefined;

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _strings = require('../values/strings');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parseEvent = function parseEvent(event, args, config) {
    var numDays = args.numDays,
        numDaysInMonth = args.numDaysInMonth,
        numDaysInLastMonth = args.numDaysInLastMonth,
        offset = args.offset,
        month = args.month,
        year = args.year,
        numTiles = args.numTiles;

    var monthOffsetLast = offset === 0 ? 0 : 1;
    var monthOffsetNext = numTiles - numDays - offset === 0 ? 0 : 1;

    var beginning = (0, _moment2.default)('\n        ' + (month === 1 ? year - 1 : year) + ' - \n        ' + (month - monthOffsetLast >= 1 ? month - monthOffsetLast : 12) + ' - \n        ' + (offset === 0 ? 1 : numDaysInLastMonth - offset + 1), 'YYYY-M-D');

    var end = (0, _moment2.default)('\n        ' + (month === 12 ? year + 1 : year) + ' - \n        ' + (month + monthOffsetNext >= 12 ? 1 : month + monthOffsetNext) + ' - \n        ' + (monthOffsetNext === 0 ? numDays : numTiles - numDays - offset), 'YYYY-M-D');

    var startDateString = (0, _moment2.default)(event.start, config.dateFormat);

    var endDateString = (0, _moment2.default)(event.end, config.dateFormat);

    var parsedMonth = startDateString.month() + 1;
    var parsedMonthEnd = endDateString.month() + 1;
    var parsedDay = startDateString.date();
    var parsedEnd = endDateString.date();

    var numDaysInNextMonth = numDaysInMonth[parsedMonth + 1 < 12 ? parsedMonth + 1 : 0];

    var isBelowEventRange = !startDateString.isBetween(beginning, end, 'days', '[]');
    var isAboveEventRange = !endDateString.isBetween(beginning, end, 'days', '[]');

    if (isBelowEventRange && !isAboveEventRange) {
        parsedDay = numDaysInMonth[month - 2 >= 0 ? month - 2 : 11] - offset + 1;
    }

    if (parsedMonth !== parsedMonthEnd && parsedMonth === (month - 1 >= 1 ? month - 1 : 12) && parsedDay >= beginning.date()) {
        parsedEnd = numDaysInLastMonth + parsedEnd;
    }

    if (parsedMonth !== parsedMonthEnd && parsedMonthEnd === (month + 1 <= 12 ? month + 1 : 1)) {
        if (numDaysInNextMonth + parsedEnd > numTiles) {
            parsedEnd = numTiles + 1;
        } else {
            parsedEnd = numDays + parsedEnd;
        }
    }

    return {
        parsedDay: parsedDay,
        parsedEnd: parsedEnd,
        parsedMonth: parsedMonth,
        parsedMonthEnd: parsedMonthEnd,
        startDateString: startDateString,
        endDateString: endDateString,
        isBelowEventRange: isBelowEventRange,
        isAboveEventRange: isAboveEventRange
    };
};

var reorderEvents = function reorderEvents(args) {
    var calendarList = args.calendarList,
        numTiles = args.numTiles,
        config = args.config;

    var tileOverflowOffset = numTiles > 35 ? 1 : 0;
    var overflowLength = 3 - tileOverflowOffset;
    var multiEventPositions = [];
    var difference = 0;

    calendarList.map(function (eventArray, index) {
        // A nono position is a spot in the eventArray that is reserved by a multi-day event in a previous tile.
        // We need to keep track of these positions so that they are not overrided when sorting.
        var nonoPositions = [];

        // Loop through previous tile and store multi-day event positions so that we can keep track of them when
        // determining the order of placeholder events.
        if (index !== 0) {
            calendarList[index - 1].map(function (previousEvent, previousArrayIndex) {
                var _parseEvent = parseEvent(previousEvent, args, config),
                    parsedDay = _parseEvent.parsedDay,
                    parsedEnd = _parseEvent.parsedEnd;

                if (previousEvent.type === _strings.MULTI_DAY_TYPE) {
                    difference = parsedEnd - parsedDay;
                    multiEventPositions = multiEventPositions.concat([[previousArrayIndex, difference, index - 1]]);
                }

                // If multi-day event is going to overflow, show that event continues over multiple days in overflow count.
                if (calendarList[index - 1].length >= overflowLength) {
                    if (previousEvent.type === _strings.MULTI_DAY_TYPE && calendarList[index - 1].indexOf(previousEvent) >= 3 - tileOverflowOffset) {
                        for (var z = index - 1; z < index - 1 + (parsedEnd - parsedDay); z++) {
                            if (z < numTiles && calendarList.length === overflowLength) {
                                calendarList[z].length = calendarList[z].length + 1;
                            }
                        }
                    }
                }

                return 0; // Get rid of warning
            });
        }

        // If we have navigated through one row, reset multiEventPositions.
        if (_strings.wrappingTiles.includes(index - 1)) {
            multiEventPositions = [];
            return 0;
        }

        // NoNo positions
        multiEventPositions.map(function (position) {
            if (Math.abs(index + 1 - position[1]) <= position[2]) {
                nonoPositions.push(position[0]);
            }
            return 0;
        });

        eventArray.map(function (event, arrayIndex) {
            if (event.type !== _strings.PLACEHOLDER_TYPE && nonoPositions.includes(arrayIndex)) {

                // Search for position to swap.
                for (var z = 0; z < calendarList[index].length; z++) {
                    if (calendarList[index][z].type === _strings.PLACEHOLDER_TYPE && !nonoPositions.includes(z) && z !== arrayIndex) {
                        var temp = calendarList[index][z];
                        calendarList[index][z] = calendarList[index][arrayIndex];
                        calendarList[index][arrayIndex] = temp;
                    }
                }
            }
            return 0;
        });

        // Reorder tile so that placeholders are in the same array position as their multi-day event parents.


        return 0; // Get rid of warning
    });
};

var determineIndex = function determineIndex(parsedDay, args) {
    var parsedMonth = args.parsedMonth,
        month = args.month,
        offset = args.offset,
        numDaysInLastMonth = args.numDaysInLastMonth,
        numDays = args.numDays;

    switch (true) {
        // Event belongs to 'this' month
        case parsedMonth === month:
            return parsedDay + offset - 1;

        // Event belongs to previous month
        case parsedMonth === (month - 1 >= 1 ? month - 1 : 12):
            return parsedDay - numDaysInLastMonth + offset - 1;

        // Event belongs to next month
        default:
            return numDays + parsedDay + offset - 1;
    }
};

var wrapLongEvent = function wrapLongEvent(event, ranOnce, calendarList, parts, i, config) {
    var parsedDay = parts.parsedDay,
        parsedEnd = parts.parsedEnd,
        offset = parts.offset,
        numTiles = parts.numTiles,
        month = parts.month,
        numDaysInLastMonth = parts.numDaysInLastMonth,
        numDays = parts.numDays;


    var endMonth = (0, _moment2.default)(event.end).month() + 1;

    var startMonth = (0, _moment2.default)(event.start).month() + 1;

    var start = 0,
        end = 0;

    start = determineIndex(parsedDay, { parsedMonth: startMonth, month: month, offset: offset, numDays: numDays, numDaysInLastMonth: numDaysInLastMonth });
    end = determineIndex(parsedEnd, { parsedMonth: startMonth, month: month, offset: offset, numDays: numDays, numDaysInLastMonth: numDaysInLastMonth });

    _strings.wrappingTiles.map(function (tileNum) {

        if (start < tileNum + 1 && end > tileNum + 1 && i !== numTiles - 1 && !ranOnce && tileNum !== numTiles - 1) {

            // If a multi-day event takes place over one of the wrapping tiles, it will need to be
            // split into two events to prevent styles from overflowing past calendar border.
            // e.g. 2019-05-19 - 2019-05-22 -> 2019-05-19 - 2019-05-20 && 2019-05-21 - 2019-05-22 where day 20 is on the edge
            var original = calendarList[i].shift();

            // Create deep copies. Fairly slow, but easiest way to make a deep copy since JS does not
            // natively support deep copies.
            var firstEvent = JSON.parse(JSON.stringify(original));
            var secondEvent = JSON.parse(JSON.stringify(original));

            var firstEnd = (0, _moment2.default)(firstEvent.end);

            if (firstEnd.month() !== month) {
                firstEnd.set('month', month - 1);
            }

            firstEnd.set('date', tileNum - offset + 2);

            firstEvent.end = firstEnd.format(config.dateFormat);

            calendarList[i].unshift(firstEvent);

            var secondStart = (0, _moment2.default)(secondEvent.start);

            if (secondStart.month() !== month) {
                secondStart.set('month', month - 1);
            }

            secondStart.set('date', tileNum - offset + 2);

            secondEvent.start = secondStart.format(config.dateFormat);

            var newParts = {
                parsedDay: tileNum - offset + 2,
                parsedEnd: startMonth !== endMonth ? parsedEnd - numDays : parsedEnd,
                numTiles: numTiles,
                offset: offset,
                month: month
            };

            if (calendarList[tileNum + 1]) {
                calendarList[tileNum + 1].unshift(secondEvent);
            }

            wrapLongEvent(secondEvent, ranOnce, calendarList, newParts, tileNum + 1, event, config);

            ranOnce = true;
        }
        return 0; // Get rid of warning
    });
};

var computeDifferences = function computeDifferences(firstDateCreated, secondDateCreated, firstEvent, secondEvent, args) {
    var firstDateStart = args.firstDateStart,
        firstDateEnd = args.firstDateEnd,
        secondDateStart = args.secondDateStart,
        secondDateEnd = args.secondDateEnd,
        month = args.month,
        numDaysInMonth = args.numDaysInMonth;

    var numDays = numDaysInMonth[month - 1];

    switch (true) {
        // sort single day events by the date they were created
        case firstDateStart.date() === firstDateEnd.date() - 1 && secondDateStart.date() === secondDateEnd.date() - 1:
            return secondDateCreated.diff(firstDateCreated);

        case firstDateStart.date() === firstDateEnd.date() - 1:
            return -1;

        case secondDateStart.date() === secondDateEnd.date() - 1:
            return 1;

        case firstDateStart.month() !== firstDateEnd.month():
            return Math.abs(numDays - firstDateStart.date() - firstDateEnd.date()) - Math.abs(secondDateStart.date() - secondDateEnd.date());

        case secondDateStart.month() !== secondDateEnd.month():
            return Math.abs(firstDateStart.date() - firstDateEnd.date()) - Math.abs(numDays - secondDateStart.date() - secondDateEnd.date());

        default:
            return Math.abs(firstDateStart.date() - firstDateEnd.date()) - Math.abs(secondDateStart.date() - secondDateEnd.date()) === 0 ? secondDateCreated.diff(firstDateCreated) : Math.abs(firstDateStart.date() - firstDateEnd.date()) - Math.abs(secondDateStart.date() - secondDateEnd.date());

    }
};

var parseConfig = function parseConfig(config) {

    for (var key in _strings.defaultConfig) {
        if (!config.hasOwnProperty(key)) {
            config[key] = _strings.defaultConfig[key];
        }
    }
};

exports.parseEvent = parseEvent;
exports.reorderEvents = reorderEvents;
exports.parseConfig = parseConfig;
exports.wrapLongEvent = wrapLongEvent;
exports.computeDifferences = computeDifferences;
