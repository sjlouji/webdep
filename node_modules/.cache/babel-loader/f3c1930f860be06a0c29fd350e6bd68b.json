{"ast":null,"code":"import _defineProperty from\"/Users/joan/Documents/Drive/Projects/punithargal.org/api/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/Users/joan/Documents/Drive/Projects/punithargal.org/api/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{VIDEO_DETAILS,WATCH_DETAILS}from'../actions/watch';import{SUCCESS}from'../actions';import{CHANNEL_LIST_RESPONSE}from'../api/youtube-api-response-types';var initialState={byId:{}};export default function(){var state=arguments.length>0&&arguments[0]!==undefined?arguments[0]:initialState;var action=arguments.length>1?arguments[1]:undefined;switch(action.type){case WATCH_DETAILS[SUCCESS]:return reduceWatchDetails(action.response,state);case VIDEO_DETAILS[SUCCESS]:return reduceVideoDetails(action.response,state);default:return state;}}function reduceWatchDetails(responses,prevState){var channelResponse=responses.find(function(response){return response.result.kind===CHANNEL_LIST_RESPONSE;});var channels={};if(channelResponse&&channelResponse.result.items){// we know that there will only be one item\n// because we ask for a channel with a specific id\nvar channel=channelResponse.result.items[0];channels[channel.id]=channel;}return _objectSpread(_objectSpread({},prevState),{},{byId:_objectSpread(_objectSpread({},prevState.byId),channels)});}function reduceVideoDetails(responses,prevState){var channelResponse=responses.find(function(response){return response.result.kind===CHANNEL_LIST_RESPONSE;});var channelEntry={};if(channelResponse&&channelResponse.result.items){// we're explicitly asking for a channel with a particular id\n// so the response set must either contain 0 items (if a channel with the specified id does not exist)\n// or at most one item (i.e. the channel we've been asking for)\nvar channel=channelResponse.result.items[0];channelEntry=_defineProperty({},channel.id,channel);}return _objectSpread(_objectSpread({},prevState),{},{byId:_objectSpread(_objectSpread({},prevState.byId),channelEntry)});}/*\n*   Selectors\n* */export var getChannel=function getChannel(state,channelId){if(!channelId)return null;return state.channels.byId[channelId];};","map":{"version":3,"sources":["/Users/joan/Documents/Drive/Projects/punithargal.org/api/frontend/src/store/reducers/channels.js"],"names":["VIDEO_DETAILS","WATCH_DETAILS","SUCCESS","CHANNEL_LIST_RESPONSE","initialState","byId","state","action","type","reduceWatchDetails","response","reduceVideoDetails","responses","prevState","channelResponse","find","result","kind","channels","items","channel","id","channelEntry","getChannel","channelId"],"mappings":"iXAAA,OAAQA,aAAR,CAAuBC,aAAvB,KAA2C,kBAA3C,CACA,OAAQC,OAAR,KAAsB,YAAtB,CACA,OAAQC,qBAAR,KAAoC,mCAApC,CAEA,GAAMC,CAAAA,YAAY,CAAG,CACnBC,IAAI,CAAE,EADa,CAArB,CAIA,cAAe,WAAwC,IAA9BC,CAAAA,KAA8B,2DAAtBF,YAAsB,IAARG,CAAAA,MAAQ,2CACrD,OAAQA,MAAM,CAACC,IAAf,EACE,IAAKP,CAAAA,aAAa,CAACC,OAAD,CAAlB,CACE,MAAOO,CAAAA,kBAAkB,CAACF,MAAM,CAACG,QAAR,CAAkBJ,KAAlB,CAAzB,CACF,IAAKN,CAAAA,aAAa,CAACE,OAAD,CAAlB,CACE,MAAOS,CAAAA,kBAAkB,CAACJ,MAAM,CAACG,QAAR,CAAkBJ,KAAlB,CAAzB,CACF,QACE,MAAOA,CAAAA,KAAP,CANJ,CAQD,CAED,QAASG,CAAAA,kBAAT,CAA4BG,SAA5B,CAAuCC,SAAvC,CAAkD,CAChD,GAAMC,CAAAA,eAAe,CAAGF,SAAS,CAACG,IAAV,CAAe,SAAAL,QAAQ,QAAIA,CAAAA,QAAQ,CAACM,MAAT,CAAgBC,IAAhB,GAAyBd,qBAA7B,EAAvB,CAAxB,CACA,GAAIe,CAAAA,QAAQ,CAAG,EAAf,CACA,GAAIJ,eAAe,EAAIA,eAAe,CAACE,MAAhB,CAAuBG,KAA9C,CAAqD,CACnD;AACA;AACA,GAAMC,CAAAA,OAAO,CAAGN,eAAe,CAACE,MAAhB,CAAuBG,KAAvB,CAA6B,CAA7B,CAAhB,CACAD,QAAQ,CAACE,OAAO,CAACC,EAAT,CAAR,CAAuBD,OAAvB,CACD,CACD,sCACKP,SADL,MAEER,IAAI,gCACCQ,SAAS,CAACR,IADX,EAECa,QAFD,CAFN,GAOD,CAED,QAASP,CAAAA,kBAAT,CAA4BC,SAA5B,CAAuCC,SAAvC,CAAkD,CAChD,GAAMC,CAAAA,eAAe,CAAGF,SAAS,CAACG,IAAV,CAAe,SAAAL,QAAQ,QAAIA,CAAAA,QAAQ,CAACM,MAAT,CAAgBC,IAAhB,GAAyBd,qBAA7B,EAAvB,CAAxB,CACA,GAAImB,CAAAA,YAAY,CAAG,EAAnB,CACA,GAAIR,eAAe,EAAIA,eAAe,CAACE,MAAhB,CAAuBG,KAA9C,CAAqD,CACnD;AACA;AACA;AACA,GAAMC,CAAAA,OAAO,CAAGN,eAAe,CAACE,MAAhB,CAAuBG,KAAvB,CAA6B,CAA7B,CAAhB,CACAG,YAAY,oBACTF,OAAO,CAACC,EADC,CACID,OADJ,CAAZ,CAGD,CAED,sCACKP,SADL,MAEER,IAAI,gCACCQ,SAAS,CAACR,IADX,EAECiB,YAFD,CAFN,GAOD,CAED;;IAGA,MAAO,IAAMC,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAACjB,KAAD,CAAQkB,SAAR,CAAsB,CAC9C,GAAI,CAACA,SAAL,CAAgB,MAAO,KAAP,CAChB,MAAOlB,CAAAA,KAAK,CAACY,QAAN,CAAeb,IAAf,CAAoBmB,SAApB,CAAP,CACD,CAHM","sourcesContent":["import {VIDEO_DETAILS, WATCH_DETAILS} from '../actions/watch';\nimport {SUCCESS} from '../actions';\nimport {CHANNEL_LIST_RESPONSE} from '../api/youtube-api-response-types';\n\nconst initialState = {\n  byId: {}\n};\n\nexport default function (state = initialState, action) {\n  switch (action.type) {\n    case WATCH_DETAILS[SUCCESS]:\n      return reduceWatchDetails(action.response, state);\n    case VIDEO_DETAILS[SUCCESS]:\n      return reduceVideoDetails(action.response, state);\n    default:\n      return state;\n  }\n}\n\nfunction reduceWatchDetails(responses, prevState) {\n  const channelResponse = responses.find(response => response.result.kind === CHANNEL_LIST_RESPONSE);\n  let channels = {};\n  if (channelResponse && channelResponse.result.items) {\n    // we know that there will only be one item\n    // because we ask for a channel with a specific id\n    const channel = channelResponse.result.items[0];\n    channels[channel.id] = channel;\n  }\n  return {\n    ...prevState,\n    byId: {\n      ...prevState.byId,\n      ...channels\n    }\n  };\n}\n\nfunction reduceVideoDetails(responses, prevState) {\n  const channelResponse = responses.find(response => response.result.kind === CHANNEL_LIST_RESPONSE);\n  let channelEntry = {};\n  if (channelResponse && channelResponse.result.items) {\n    // we're explicitly asking for a channel with a particular id\n    // so the response set must either contain 0 items (if a channel with the specified id does not exist)\n    // or at most one item (i.e. the channel we've been asking for)\n    const channel = channelResponse.result.items[0];\n    channelEntry =  {\n      [channel.id]: channel,\n    }\n  }\n\n  return {\n    ...prevState,\n    byId: {\n      ...prevState.byId,\n      ...channelEntry,\n    }\n  };\n}\n\n/*\n*   Selectors\n* */\nexport const getChannel = (state, channelId) => {\n  if (!channelId) return null;\n  return state.channels.byId[channelId];\n};"]},"metadata":{},"sourceType":"module"}