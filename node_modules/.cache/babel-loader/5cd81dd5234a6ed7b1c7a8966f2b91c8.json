{"ast":null,"code":"import { MOST_POPULAR, MOST_POPULAR_BY_CATEGORY, VIDEO_CATEGORIES } from '../actions/video';\nimport { SUCCESS } from '../actions';\nimport { createSelector } from 'reselect';\nimport { SEARCH_LIST_RESPONSE, VIDEO_LIST_RESPONSE } from '../api/youtube-api-response-types';\nimport { VIDEO_DETAILS, WATCH_DETAILS } from '../actions/watch';\nimport { getSearchParam } from '../../services/url';\nexport const initialState = {\n  byId: {},\n  mostPopular: {},\n  categories: {},\n  byCategory: {},\n  related: {}\n};\nexport default function videos(state = initialState, action) {\n  switch (action.type) {\n    case MOST_POPULAR[SUCCESS]:\n      return reduceFetchMostPopularVideos(action.response, state);\n\n    case VIDEO_CATEGORIES[SUCCESS]:\n      return reduceFetchVideoCategories(action.response, state);\n\n    case MOST_POPULAR_BY_CATEGORY[SUCCESS]:\n      return reduceFetchMostPopularVideosByCategory(action.response, action.categories, state);\n\n    case WATCH_DETAILS[SUCCESS]:\n      return reduceWatchDetails(action.response, state);\n\n    case VIDEO_DETAILS[SUCCESS]:\n      return reduceVideoDetails(action.response, state);\n\n    default:\n      return state;\n  }\n}\n\nfunction reduceFetchMostPopularVideos(response, prevState) {\n  const videoMap = response.items.reduce((accumulator, video) => {\n    accumulator[video.id] = video;\n    return accumulator;\n  }, {});\n  let items = Object.keys(videoMap);\n\n  if (response.hasOwnProperty('prevPageToken') && prevState.mostPopular) {\n    items = [...prevState.mostPopular.items, ...items];\n  }\n\n  const mostPopular = {\n    totalResults: response.pageInfo.totalResults,\n    nextPageToken: response.nextPageToken,\n    items\n  };\n  return { ...prevState,\n    mostPopular,\n    byId: { ...prevState.byId,\n      ...videoMap\n    }\n  };\n}\n\nfunction reduceFetchVideoCategories(response, prevState) {\n  const categoryMapping = response.items.reduce((accumulator, category) => {\n    accumulator[category.id] = category.snippet.title;\n    return accumulator;\n  }, {});\n  return { ...prevState,\n    categories: categoryMapping\n  };\n}\n\nfunction reduceFetchMostPopularVideosByCategory(responses, categories, prevState) {\n  let videoMap = {};\n  let byCategoryMap = {};\n  responses.forEach((response, index) => {\n    // ignore answer if there was an error\n    if (response.status === 400) return;\n    const categoryId = categories[index];\n    const {\n      byId,\n      byCategory\n    } = groupVideosByIdAndCategory(response.result);\n    videoMap = { ...videoMap,\n      ...byId\n    };\n    byCategoryMap[categoryId] = byCategory;\n  }); // compute new state\n\n  return { ...prevState,\n    byId: { ...prevState.byId,\n      ...videoMap\n    },\n    byCategory: { ...prevState.byCategory,\n      ...byCategoryMap\n    }\n  };\n}\n\nfunction groupVideosByIdAndCategory(response) {\n  const videos = response.items;\n  const byId = {};\n  const byCategory = {\n    totalResults: response.pageInfo.totalResults,\n    nextPageToken: response.nextPageToken,\n    items: []\n  };\n  videos.forEach(video => {\n    byId[video.id] = video;\n    const items = byCategory.items;\n\n    if (items && items) {\n      items.push(video.id);\n    } else {\n      byCategory.items = [video.id];\n    }\n  });\n  return {\n    byId,\n    byCategory\n  };\n}\n\nfunction reduceWatchDetails(responses, prevState) {\n  const videoDetailResponse = responses.find(r => r.result.kind === VIDEO_LIST_RESPONSE); // we know that items will only have one element\n  // because we explicitly asked for a video with a specific id\n\n  const video = videoDetailResponse.result.items[0];\n  const relatedEntry = reduceRelatedVideosRequest(responses);\n  return { ...prevState,\n    byId: { ...prevState.byId,\n      [video.id]: video\n    },\n    related: { ...prevState.related,\n      [video.id]: relatedEntry\n    }\n  };\n}\n\nfunction reduceRelatedVideosRequest(responses) {\n  const relatedVideosResponse = responses.find(r => r.result.kind === SEARCH_LIST_RESPONSE);\n  const {\n    pageInfo,\n    items,\n    nextPageToken\n  } = relatedVideosResponse.result;\n  const relatedVideoIds = items.map(video => video.id.videoId);\n  return {\n    totalResults: pageInfo.totalResults,\n    nextPageToken,\n    items: relatedVideoIds\n  };\n}\n\nfunction reduceVideoDetails(responses, prevState) {\n  const videoResponses = responses.filter(response => response.result.kind === VIDEO_LIST_RESPONSE);\n  const parsedVideos = videoResponses.reduce((videoMap, response) => {\n    // we're explicitly asking for a video with a particular id\n    // so the response set must either contain 0 items (if a video with the id does not exist)\n    // or at most one item (i.e. the channel we've been asking for)\n    const video = response.result.items ? response.result.items[0] : null;\n\n    if (!video) {\n      return videoMap;\n    }\n\n    videoMap[video.id] = video;\n    return videoMap;\n  }, {});\n  return { ...prevState,\n    byId: { ...prevState.byId,\n      ...parsedVideos\n    }\n  };\n}\n/* function reduceVideoDetails(responses) {\n  const videoResponses = responses.filter(response => response.result.kind === VIDEO_LIST_RESPONSE);\n  return videoResponses.reduce((accumulator, response) => {\n    response.result.items.forEach(video => {\n      accumulator[video.id] = video;\n    });\n    return accumulator;\n  }, {});\n}\n\nfunction reduceRelatedVideos(responses, videoIds) {\n  const videoResponses = responses.filter(response => response.result.kind === SEARCH_LIST_RESPONSE);\n  return videoResponses.reduce((accumulator, response, index) => {\n    const relatedIds = response.result.items.map(video => video.id.videoId);\n    accumulator[videoIds[index]] = {\n      totalResults: response.result.pageInfo.totalResults,\n      nextPageToken: response.result.nextPageToken,\n      items: relatedIds\n    };\n    return accumulator;\n  }, {});\n} */\n\n/*\n*   Selectors\n* */\n\n\nconst getMostPopular = state => state.videos.mostPopular;\n\nexport const getMostPopularVideos = createSelector(state => state.videos.byId, getMostPopular, (videosById, mostPopular) => {\n  if (!mostPopular || !mostPopular.items) {\n    return [];\n  }\n\n  return mostPopular.items.map(videoId => videosById[videoId]);\n});\nexport const getVideoCategoryIds = createSelector(state => state.videos.categories, categories => {\n  return Object.keys(categories || {});\n});\nexport const getVideosByCategory = createSelector(state => state.videos.byCategory, state => state.videos.byId, state => state.videos.categories, (videosByCategory, videosById, categories) => {\n  return Object.keys(videosByCategory || {}).reduce((accumulator, categoryId) => {\n    const videoIds = videosByCategory[categoryId].items;\n    const categoryTitle = categories[categoryId];\n    accumulator[categoryTitle] = videoIds.map(videoId => videosById[videoId]);\n    return accumulator;\n  }, {});\n});\nexport const videoCategoriesLoaded = createSelector(state => state.videos.categories, categories => {\n  return Object.keys(categories || {}).length !== 0;\n});\nexport const videosByCategoryLoaded = createSelector(state => state.videos.byCategory, videosByCategory => {\n  return Object.keys(videosByCategory || {}).length;\n});\nexport const getVideoById = (state, videoId) => {\n  return state.videos.byId[videoId];\n};\n\nconst getRelatedVideoIds = (state, videoId) => {\n  const related = state.videos.related[videoId];\n  return related ? related.items : [];\n};\n\nexport const getRelatedVideos = createSelector(getRelatedVideoIds, state => state.videos.byId, (relatedVideoIds, videos) => {\n  if (relatedVideoIds) {\n    // filter kicks out null values we might have\n    return relatedVideoIds.map(videoId => videos[videoId]).filter(video => video);\n  }\n\n  return [];\n});\nexport const getChannelId = (state, location, name) => {\n  const videoId = getSearchParam(location, name);\n  const video = state.videos.byId[videoId];\n\n  if (video) {\n    return video.snippet.channelId;\n  }\n\n  return null;\n};\nexport const getAmountComments = createSelector(getVideoById, video => {\n  if (video) {\n    return video.statistics.commentCount;\n  }\n\n  return 0;\n});\nexport const allMostPopularVideosLoaded = createSelector([getMostPopular], mostPopular => {\n  const amountFetchedItems = mostPopular.items ? mostPopular.items.length : 0;\n  return amountFetchedItems === mostPopular.totalResults;\n});\nexport const getMostPopularVideosNextPageToken = createSelector([getMostPopular], mostPopular => {\n  return mostPopular.nextPageToken;\n});","map":{"version":3,"sources":["/Users/joan/Documents/Drive/Projects/punithargal.org/api/frontend/src/store/reducers/videos.js"],"names":["MOST_POPULAR","MOST_POPULAR_BY_CATEGORY","VIDEO_CATEGORIES","SUCCESS","createSelector","SEARCH_LIST_RESPONSE","VIDEO_LIST_RESPONSE","VIDEO_DETAILS","WATCH_DETAILS","getSearchParam","initialState","byId","mostPopular","categories","byCategory","related","videos","state","action","type","reduceFetchMostPopularVideos","response","reduceFetchVideoCategories","reduceFetchMostPopularVideosByCategory","reduceWatchDetails","reduceVideoDetails","prevState","videoMap","items","reduce","accumulator","video","id","Object","keys","hasOwnProperty","totalResults","pageInfo","nextPageToken","categoryMapping","category","snippet","title","responses","byCategoryMap","forEach","index","status","categoryId","groupVideosByIdAndCategory","result","push","videoDetailResponse","find","r","kind","relatedEntry","reduceRelatedVideosRequest","relatedVideosResponse","relatedVideoIds","map","videoId","videoResponses","filter","parsedVideos","getMostPopular","getMostPopularVideos","videosById","getVideoCategoryIds","getVideosByCategory","videosByCategory","videoIds","categoryTitle","videoCategoriesLoaded","length","videosByCategoryLoaded","getVideoById","getRelatedVideoIds","getRelatedVideos","getChannelId","location","name","channelId","getAmountComments","statistics","commentCount","allMostPopularVideosLoaded","amountFetchedItems","getMostPopularVideosNextPageToken"],"mappings":"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","sourcesContent":["import {MOST_POPULAR, MOST_POPULAR_BY_CATEGORY, VIDEO_CATEGORIES} from '../actions/video';\nimport {SUCCESS} from '../actions';\nimport {createSelector} from 'reselect';\nimport {SEARCH_LIST_RESPONSE, VIDEO_LIST_RESPONSE} from '../api/youtube-api-response-types';\nimport {VIDEO_DETAILS, WATCH_DETAILS} from '../actions/watch';\nimport {getSearchParam} from '../../services/url';\n\nexport const initialState = {\n  byId: {},\n  mostPopular: {},\n  categories: {},\n  byCategory: {},\n  related: {},\n};\nexport default function videos(state = initialState, action) {\n  switch (action.type) {\n    case MOST_POPULAR[SUCCESS]:\n      return reduceFetchMostPopularVideos(action.response, state);\n    case VIDEO_CATEGORIES[SUCCESS]:\n      return reduceFetchVideoCategories(action.response, state);\n    case MOST_POPULAR_BY_CATEGORY[SUCCESS]:\n      return reduceFetchMostPopularVideosByCategory(action.response, action.categories, state);\n    case WATCH_DETAILS[SUCCESS]:\n      return reduceWatchDetails(action.response, state);\n    case VIDEO_DETAILS[SUCCESS]:\n      return reduceVideoDetails(action.response, state);\n    default:\n      return state;\n  }\n}\n\nfunction reduceFetchMostPopularVideos(response, prevState) {\n  const videoMap = response.items.reduce((accumulator, video) => {\n    accumulator[video.id] = video;\n    return accumulator;\n  }, {});\n\n  let items = Object.keys(videoMap);\n  if (response.hasOwnProperty('prevPageToken') && prevState.mostPopular) {\n    items = [...prevState.mostPopular.items, ...items];\n  }\n\n  const mostPopular = {\n    totalResults: response.pageInfo.totalResults,\n    nextPageToken: response.nextPageToken,\n    items,\n  };\n\n  return {\n    ...prevState,\n    mostPopular,\n    byId: {...prevState.byId, ...videoMap},\n  };\n}\n\nfunction reduceFetchVideoCategories(response, prevState) {\n  const categoryMapping = response.items.reduce((accumulator, category) => {\n    accumulator[category.id] = category.snippet.title;\n    return accumulator;\n  }, {});\n  return {\n    ...prevState,\n    categories: categoryMapping,\n  };\n}\n\nfunction reduceFetchMostPopularVideosByCategory(responses, categories, prevState) {\n  let videoMap = {};\n  let byCategoryMap = {};\n\n  responses.forEach((response, index) => {\n    // ignore answer if there was an error\n    if (response.status === 400) return;\n\n    const categoryId = categories[index];\n    const {byId, byCategory} = groupVideosByIdAndCategory(response.result);\n    videoMap = {...videoMap, ...byId};\n    byCategoryMap[categoryId] = byCategory;\n  });\n\n  // compute new state\n  return {\n    ...prevState,\n    byId: {...prevState.byId, ...videoMap},\n    byCategory: {...prevState.byCategory, ...byCategoryMap},\n  };\n}\n\nfunction groupVideosByIdAndCategory(response) {\n  const videos = response.items;\n  const byId = {};\n  const byCategory = {\n    totalResults: response.pageInfo.totalResults,\n    nextPageToken: response.nextPageToken,\n    items: [],\n  };\n\n  videos.forEach((video) => {\n    byId[video.id] = video;\n\n    const items = byCategory.items;\n    if(items && items) {\n      items.push(video.id);\n    } else {\n      byCategory.items = [video.id];\n    }\n  });\n\n  return {byId, byCategory};\n}\n\nfunction reduceWatchDetails(responses, prevState) {\n  const videoDetailResponse = responses.find(r => r.result.kind === VIDEO_LIST_RESPONSE);\n  // we know that items will only have one element\n  // because we explicitly asked for a video with a specific id\n  const video = videoDetailResponse.result.items[0];\n  const relatedEntry = reduceRelatedVideosRequest(responses);\n\n  return {\n    ...prevState,\n    byId: {\n      ...prevState.byId,\n      [video.id]: video\n    },\n    related: {\n      ...prevState.related,\n      [video.id]: relatedEntry\n    }\n  };\n}\n\nfunction reduceRelatedVideosRequest(responses) {\n  const relatedVideosResponse = responses.find(r => r.result.kind === SEARCH_LIST_RESPONSE);\n  const {pageInfo, items, nextPageToken} = relatedVideosResponse.result;\n  const relatedVideoIds = items.map(video => video.id.videoId);\n\n  return {\n    totalResults: pageInfo.totalResults,\n    nextPageToken,\n    items: relatedVideoIds\n  };\n}\n\nfunction reduceVideoDetails(responses, prevState) {\n  const videoResponses = responses.filter(response => response.result.kind === VIDEO_LIST_RESPONSE);\n  const parsedVideos = videoResponses.reduce((videoMap, response) => {\n    // we're explicitly asking for a video with a particular id\n    // so the response set must either contain 0 items (if a video with the id does not exist)\n    // or at most one item (i.e. the channel we've been asking for)\n    const video = response.result.items ? response.result.items[0] : null;\n    if (!video) {\n      return videoMap;\n    }\n    videoMap[video.id] = video;\n    return videoMap;\n  }, {});\n\n  return {\n    ...prevState,\n    byId: {...prevState.byId, ...parsedVideos},\n  };\n}\n\n/* function reduceVideoDetails(responses) {\n  const videoResponses = responses.filter(response => response.result.kind === VIDEO_LIST_RESPONSE);\n  return videoResponses.reduce((accumulator, response) => {\n    response.result.items.forEach(video => {\n      accumulator[video.id] = video;\n    });\n    return accumulator;\n  }, {});\n}\n\nfunction reduceRelatedVideos(responses, videoIds) {\n  const videoResponses = responses.filter(response => response.result.kind === SEARCH_LIST_RESPONSE);\n  return videoResponses.reduce((accumulator, response, index) => {\n    const relatedIds = response.result.items.map(video => video.id.videoId);\n    accumulator[videoIds[index]] = {\n      totalResults: response.result.pageInfo.totalResults,\n      nextPageToken: response.result.nextPageToken,\n      items: relatedIds\n    };\n    return accumulator;\n  }, {});\n} */\n\n\n/*\n*   Selectors\n* */\nconst getMostPopular = (state) => state.videos.mostPopular;\nexport const getMostPopularVideos = createSelector(\n  (state) => state.videos.byId,\n  getMostPopular,\n  (videosById, mostPopular) => {\n    if (!mostPopular || !mostPopular.items) {\n      return [];\n    }\n    return mostPopular.items.map(videoId => videosById[videoId]);\n  }\n);\nexport const getVideoCategoryIds = createSelector(\n  state => state.videos.categories,\n  (categories) => {\n    return Object.keys(categories || {});\n  }\n);\n\nexport const getVideosByCategory = createSelector(\n  state => state.videos.byCategory,\n  state => state.videos.byId,\n  state => state.videos.categories,\n  (videosByCategory, videosById, categories) => {\n    return Object.keys(videosByCategory || {}).reduce((accumulator, categoryId) => {\n      const videoIds = videosByCategory[categoryId].items;\n      const categoryTitle = categories[categoryId];\n      accumulator[categoryTitle] = videoIds.map(videoId => videosById[videoId]);\n      return accumulator;\n    }, {});\n  }\n);\n\nexport const videoCategoriesLoaded = createSelector(\n  state => state.videos.categories,\n  (categories) => {\n    return Object.keys(categories || {}).length !== 0;\n  }\n);\n\nexport const videosByCategoryLoaded = createSelector(\n  state => state.videos.byCategory,\n  (videosByCategory) => {\n    return Object.keys(videosByCategory || {}).length;\n  }\n);\n\nexport const getVideoById = (state, videoId) => {\n  return state.videos.byId[videoId];\n};\nconst getRelatedVideoIds = (state, videoId) => {\n  const related = state.videos.related[videoId];\n  return related ? related.items : [];\n};\nexport const getRelatedVideos = createSelector(\n  getRelatedVideoIds,\n  state => state.videos.byId,\n  (relatedVideoIds, videos) => {\n    if (relatedVideoIds) {\n      // filter kicks out null values we might have\n      return relatedVideoIds.map(videoId => videos[videoId]).filter(video => video);\n    }\n    return [];\n  });\n\nexport const getChannelId = (state, location, name) => {\n  const videoId = getSearchParam(location, name);\n  const video = state.videos.byId[videoId];\n  if (video) {\n    return video.snippet.channelId;\n  }\n  return null;\n};\n\nexport const getAmountComments = createSelector(\n  getVideoById,\n  (video) => {\n    if (video) {\n      return video.statistics.commentCount;\n    }\n    return 0;\n  });\n\nexport const allMostPopularVideosLoaded = createSelector(\n  [getMostPopular],\n  (mostPopular) => {\n    const amountFetchedItems = mostPopular.items ? mostPopular.items.length : 0;\n    return amountFetchedItems === mostPopular.totalResults;\n  }\n);\n\nexport const getMostPopularVideosNextPageToken = createSelector(\n  [getMostPopular],\n  (mostPopular) => {\n    return mostPopular.nextPageToken;\n  }\n);\n\n"]},"metadata":{},"sourceType":"module"}