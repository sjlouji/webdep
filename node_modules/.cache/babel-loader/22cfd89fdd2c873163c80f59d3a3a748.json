{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeDifferences = exports.wrapLongEvent = exports.parseConfig = exports.reorderEvents = exports.parseEvent = undefined;\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _strings = require('../values/strings');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar parseEvent = function parseEvent(event, args, config) {\n  var numDays = args.numDays,\n      numDaysInMonth = args.numDaysInMonth,\n      numDaysInLastMonth = args.numDaysInLastMonth,\n      offset = args.offset,\n      month = args.month,\n      year = args.year,\n      numTiles = args.numTiles;\n  var monthOffsetLast = offset === 0 ? 0 : 1;\n  var monthOffsetNext = numTiles - numDays - offset === 0 ? 0 : 1;\n  var beginning = (0, _moment2.default)('\\n        ' + (month === 1 ? year - 1 : year) + ' - \\n        ' + (month - monthOffsetLast >= 1 ? month - monthOffsetLast : 12) + ' - \\n        ' + (offset === 0 ? 1 : numDaysInLastMonth - offset + 1), 'YYYY-M-D');\n  var end = (0, _moment2.default)('\\n        ' + (month === 12 ? year + 1 : year) + ' - \\n        ' + (month + monthOffsetNext >= 12 ? 1 : month + monthOffsetNext) + ' - \\n        ' + (monthOffsetNext === 0 ? numDays : numTiles - numDays - offset), 'YYYY-M-D');\n  var startDateString = (0, _moment2.default)(event.start, config.dateFormat);\n  var endDateString = (0, _moment2.default)(event.end, config.dateFormat);\n  var parsedMonth = startDateString.month() + 1;\n  var parsedMonthEnd = endDateString.month() + 1;\n  var parsedDay = startDateString.date();\n  var parsedEnd = endDateString.date();\n  var numDaysInNextMonth = numDaysInMonth[parsedMonth + 1 < 12 ? parsedMonth + 1 : 0];\n  var isBelowEventRange = !startDateString.isBetween(beginning, end, 'days', '[]');\n  var isAboveEventRange = !endDateString.isBetween(beginning, end, 'days', '[]');\n\n  if (isBelowEventRange && !isAboveEventRange) {\n    parsedDay = numDaysInMonth[month - 2 >= 0 ? month - 2 : 11] - offset + 1;\n  }\n\n  if (parsedMonth !== parsedMonthEnd && parsedMonth === (month - 1 >= 1 ? month - 1 : 12) && parsedDay >= beginning.date()) {\n    parsedEnd = numDaysInLastMonth + parsedEnd;\n  }\n\n  if (parsedMonth !== parsedMonthEnd && parsedMonthEnd === (month + 1 <= 12 ? month + 1 : 1)) {\n    if (numDaysInNextMonth + parsedEnd > numTiles) {\n      parsedEnd = numTiles + 1;\n    } else {\n      parsedEnd = numDays + parsedEnd;\n    }\n  }\n\n  return {\n    parsedDay: parsedDay,\n    parsedEnd: parsedEnd,\n    parsedMonth: parsedMonth,\n    parsedMonthEnd: parsedMonthEnd,\n    startDateString: startDateString,\n    endDateString: endDateString,\n    isBelowEventRange: isBelowEventRange,\n    isAboveEventRange: isAboveEventRange\n  };\n};\n\nvar reorderEvents = function reorderEvents(args) {\n  var calendarList = args.calendarList,\n      numTiles = args.numTiles,\n      config = args.config;\n  var tileOverflowOffset = numTiles > 35 ? 1 : 0;\n  var overflowLength = 3 - tileOverflowOffset;\n  var multiEventPositions = [];\n  var difference = 0;\n  calendarList.map(function (eventArray, index) {\n    // A nono position is a spot in the eventArray that is reserved by a multi-day event in a previous tile.\n    // We need to keep track of these positions so that they are not overrided when sorting.\n    var nonoPositions = []; // Loop through previous tile and store multi-day event positions so that we can keep track of them when\n    // determining the order of placeholder events.\n\n    if (index !== 0) {\n      calendarList[index - 1].map(function (previousEvent, previousArrayIndex) {\n        var _parseEvent = parseEvent(previousEvent, args, config),\n            parsedDay = _parseEvent.parsedDay,\n            parsedEnd = _parseEvent.parsedEnd;\n\n        if (previousEvent.type === _strings.MULTI_DAY_TYPE) {\n          difference = parsedEnd - parsedDay;\n          multiEventPositions = multiEventPositions.concat([[previousArrayIndex, difference, index - 1]]);\n        } // If multi-day event is going to overflow, show that event continues over multiple days in overflow count.\n\n\n        if (calendarList[index - 1].length >= overflowLength) {\n          if (previousEvent.type === _strings.MULTI_DAY_TYPE && calendarList[index - 1].indexOf(previousEvent) >= 3 - tileOverflowOffset) {\n            for (var z = index - 1; z < index - 1 + (parsedEnd - parsedDay); z++) {\n              if (z < numTiles && calendarList.length === overflowLength) {\n                calendarList[z].length = calendarList[z].length + 1;\n              }\n            }\n          }\n        }\n\n        return 0; // Get rid of warning\n      });\n    } // If we have navigated through one row, reset multiEventPositions.\n\n\n    if (_strings.wrappingTiles.includes(index - 1)) {\n      multiEventPositions = [];\n      return 0;\n    } // NoNo positions\n\n\n    multiEventPositions.map(function (position) {\n      if (Math.abs(index + 1 - position[1]) <= position[2]) {\n        nonoPositions.push(position[0]);\n      }\n\n      return 0;\n    });\n    eventArray.map(function (event, arrayIndex) {\n      if (event.type !== _strings.PLACEHOLDER_TYPE && nonoPositions.includes(arrayIndex)) {\n        // Search for position to swap.\n        for (var z = 0; z < calendarList[index].length; z++) {\n          if (calendarList[index][z].type === _strings.PLACEHOLDER_TYPE && !nonoPositions.includes(z) && z !== arrayIndex) {\n            var temp = calendarList[index][z];\n            calendarList[index][z] = calendarList[index][arrayIndex];\n            calendarList[index][arrayIndex] = temp;\n          }\n        }\n      }\n\n      return 0;\n    }); // Reorder tile so that placeholders are in the same array position as their multi-day event parents.\n\n    return 0; // Get rid of warning\n  });\n};\n\nvar determineIndex = function determineIndex(parsedDay, args) {\n  var parsedMonth = args.parsedMonth,\n      month = args.month,\n      offset = args.offset,\n      numDaysInLastMonth = args.numDaysInLastMonth,\n      numDays = args.numDays;\n\n  switch (true) {\n    // Event belongs to 'this' month\n    case parsedMonth === month:\n      return parsedDay + offset - 1;\n    // Event belongs to previous month\n\n    case parsedMonth === (month - 1 >= 1 ? month - 1 : 12):\n      return parsedDay - numDaysInLastMonth + offset - 1;\n    // Event belongs to next month\n\n    default:\n      return numDays + parsedDay + offset - 1;\n  }\n};\n\nvar wrapLongEvent = function wrapLongEvent(event, ranOnce, calendarList, parts, i, config) {\n  var parsedDay = parts.parsedDay,\n      parsedEnd = parts.parsedEnd,\n      offset = parts.offset,\n      numTiles = parts.numTiles,\n      month = parts.month,\n      numDaysInLastMonth = parts.numDaysInLastMonth,\n      numDays = parts.numDays;\n  var endMonth = (0, _moment2.default)(event.end).month() + 1;\n  var startMonth = (0, _moment2.default)(event.start).month() + 1;\n  var start = 0,\n      end = 0;\n  start = determineIndex(parsedDay, {\n    parsedMonth: startMonth,\n    month: month,\n    offset: offset,\n    numDays: numDays,\n    numDaysInLastMonth: numDaysInLastMonth\n  });\n  end = determineIndex(parsedEnd, {\n    parsedMonth: startMonth,\n    month: month,\n    offset: offset,\n    numDays: numDays,\n    numDaysInLastMonth: numDaysInLastMonth\n  });\n\n  _strings.wrappingTiles.map(function (tileNum) {\n    if (start < tileNum + 1 && end > tileNum + 1 && i !== numTiles - 1 && !ranOnce && tileNum !== numTiles - 1) {\n      // If a multi-day event takes place over one of the wrapping tiles, it will need to be\n      // split into two events to prevent styles from overflowing past calendar border.\n      // e.g. 2019-05-19 - 2019-05-22 -> 2019-05-19 - 2019-05-20 && 2019-05-21 - 2019-05-22 where day 20 is on the edge\n      var original = calendarList[i].shift(); // Create deep copies. Fairly slow, but easiest way to make a deep copy since JS does not\n      // natively support deep copies.\n\n      var firstEvent = JSON.parse(JSON.stringify(original));\n      var secondEvent = JSON.parse(JSON.stringify(original));\n      var firstEnd = (0, _moment2.default)(firstEvent.end);\n\n      if (firstEnd.month() !== month) {\n        firstEnd.set('month', month - 1);\n      }\n\n      firstEnd.set('date', tileNum - offset + 2);\n      firstEvent.end = firstEnd.format(config.dateFormat);\n      calendarList[i].unshift(firstEvent);\n      var secondStart = (0, _moment2.default)(secondEvent.start);\n\n      if (secondStart.month() !== month) {\n        secondStart.set('month', month - 1);\n      }\n\n      secondStart.set('date', tileNum - offset + 2);\n      secondEvent.start = secondStart.format(config.dateFormat);\n      var newParts = {\n        parsedDay: tileNum - offset + 2,\n        parsedEnd: startMonth !== endMonth ? parsedEnd - numDays : parsedEnd,\n        numTiles: numTiles,\n        offset: offset,\n        month: month\n      };\n\n      if (calendarList[tileNum + 1]) {\n        calendarList[tileNum + 1].unshift(secondEvent);\n      }\n\n      wrapLongEvent(secondEvent, ranOnce, calendarList, newParts, tileNum + 1, event, config);\n      ranOnce = true;\n    }\n\n    return 0; // Get rid of warning\n  });\n};\n\nvar computeDifferences = function computeDifferences(firstDateCreated, secondDateCreated, firstEvent, secondEvent, args) {\n  var firstDateStart = args.firstDateStart,\n      firstDateEnd = args.firstDateEnd,\n      secondDateStart = args.secondDateStart,\n      secondDateEnd = args.secondDateEnd,\n      month = args.month,\n      numDaysInMonth = args.numDaysInMonth;\n  var numDays = numDaysInMonth[month - 1];\n\n  switch (true) {\n    // sort single day events by the date they were created\n    case firstDateStart.date() === firstDateEnd.date() - 1 && secondDateStart.date() === secondDateEnd.date() - 1:\n      return secondDateCreated.diff(firstDateCreated);\n\n    case firstDateStart.date() === firstDateEnd.date() - 1:\n      return -1;\n\n    case secondDateStart.date() === secondDateEnd.date() - 1:\n      return 1;\n\n    case firstDateStart.month() !== firstDateEnd.month():\n      return Math.abs(numDays - firstDateStart.date() - firstDateEnd.date()) - Math.abs(secondDateStart.date() - secondDateEnd.date());\n\n    case secondDateStart.month() !== secondDateEnd.month():\n      return Math.abs(firstDateStart.date() - firstDateEnd.date()) - Math.abs(numDays - secondDateStart.date() - secondDateEnd.date());\n\n    default:\n      return Math.abs(firstDateStart.date() - firstDateEnd.date()) - Math.abs(secondDateStart.date() - secondDateEnd.date()) === 0 ? secondDateCreated.diff(firstDateCreated) : Math.abs(firstDateStart.date() - firstDateEnd.date()) - Math.abs(secondDateStart.date() - secondDateEnd.date());\n  }\n};\n\nvar parseConfig = function parseConfig(config) {\n  for (var key in _strings.defaultConfig) {\n    if (!config.hasOwnProperty(key)) {\n      config[key] = _strings.defaultConfig[key];\n    }\n  }\n};\n\nexports.parseEvent = parseEvent;\nexports.reorderEvents = reorderEvents;\nexports.parseConfig = parseConfig;\nexports.wrapLongEvent = wrapLongEvent;\nexports.computeDifferences = computeDifferences;","map":{"version":3,"sources":["/Users/joan/Documents/Drive/Projects/punithargal.org/api/frontend/node_modules/@jfschmiechen/react-event-calendar/resources/utilities/index.js"],"names":["Object","defineProperty","exports","value","computeDifferences","wrapLongEvent","parseConfig","reorderEvents","parseEvent","undefined","_moment","require","_moment2","_interopRequireDefault","_strings","obj","__esModule","default","event","args","config","numDays","numDaysInMonth","numDaysInLastMonth","offset","month","year","numTiles","monthOffsetLast","monthOffsetNext","beginning","end","startDateString","start","dateFormat","endDateString","parsedMonth","parsedMonthEnd","parsedDay","date","parsedEnd","numDaysInNextMonth","isBelowEventRange","isBetween","isAboveEventRange","calendarList","tileOverflowOffset","overflowLength","multiEventPositions","difference","map","eventArray","index","nonoPositions","previousEvent","previousArrayIndex","_parseEvent","type","MULTI_DAY_TYPE","concat","length","indexOf","z","wrappingTiles","includes","position","Math","abs","push","arrayIndex","PLACEHOLDER_TYPE","temp","determineIndex","ranOnce","parts","i","endMonth","startMonth","tileNum","original","shift","firstEvent","JSON","parse","stringify","secondEvent","firstEnd","set","format","unshift","secondStart","newParts","firstDateCreated","secondDateCreated","firstDateStart","firstDateEnd","secondDateStart","secondDateEnd","diff","key","defaultConfig","hasOwnProperty"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.computeDifferences = exports.wrapLongEvent = exports.parseConfig = exports.reorderEvents = exports.parseEvent = undefined;\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _strings = require('../values/strings');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar parseEvent = function parseEvent(event, args, config) {\n    var numDays = args.numDays,\n        numDaysInMonth = args.numDaysInMonth,\n        numDaysInLastMonth = args.numDaysInLastMonth,\n        offset = args.offset,\n        month = args.month,\n        year = args.year,\n        numTiles = args.numTiles;\n\n    var monthOffsetLast = offset === 0 ? 0 : 1;\n    var monthOffsetNext = numTiles - numDays - offset === 0 ? 0 : 1;\n\n    var beginning = (0, _moment2.default)('\\n        ' + (month === 1 ? year - 1 : year) + ' - \\n        ' + (month - monthOffsetLast >= 1 ? month - monthOffsetLast : 12) + ' - \\n        ' + (offset === 0 ? 1 : numDaysInLastMonth - offset + 1), 'YYYY-M-D');\n\n    var end = (0, _moment2.default)('\\n        ' + (month === 12 ? year + 1 : year) + ' - \\n        ' + (month + monthOffsetNext >= 12 ? 1 : month + monthOffsetNext) + ' - \\n        ' + (monthOffsetNext === 0 ? numDays : numTiles - numDays - offset), 'YYYY-M-D');\n\n    var startDateString = (0, _moment2.default)(event.start, config.dateFormat);\n\n    var endDateString = (0, _moment2.default)(event.end, config.dateFormat);\n\n    var parsedMonth = startDateString.month() + 1;\n    var parsedMonthEnd = endDateString.month() + 1;\n    var parsedDay = startDateString.date();\n    var parsedEnd = endDateString.date();\n\n    var numDaysInNextMonth = numDaysInMonth[parsedMonth + 1 < 12 ? parsedMonth + 1 : 0];\n\n    var isBelowEventRange = !startDateString.isBetween(beginning, end, 'days', '[]');\n    var isAboveEventRange = !endDateString.isBetween(beginning, end, 'days', '[]');\n\n    if (isBelowEventRange && !isAboveEventRange) {\n        parsedDay = numDaysInMonth[month - 2 >= 0 ? month - 2 : 11] - offset + 1;\n    }\n\n    if (parsedMonth !== parsedMonthEnd && parsedMonth === (month - 1 >= 1 ? month - 1 : 12) && parsedDay >= beginning.date()) {\n        parsedEnd = numDaysInLastMonth + parsedEnd;\n    }\n\n    if (parsedMonth !== parsedMonthEnd && parsedMonthEnd === (month + 1 <= 12 ? month + 1 : 1)) {\n        if (numDaysInNextMonth + parsedEnd > numTiles) {\n            parsedEnd = numTiles + 1;\n        } else {\n            parsedEnd = numDays + parsedEnd;\n        }\n    }\n\n    return {\n        parsedDay: parsedDay,\n        parsedEnd: parsedEnd,\n        parsedMonth: parsedMonth,\n        parsedMonthEnd: parsedMonthEnd,\n        startDateString: startDateString,\n        endDateString: endDateString,\n        isBelowEventRange: isBelowEventRange,\n        isAboveEventRange: isAboveEventRange\n    };\n};\n\nvar reorderEvents = function reorderEvents(args) {\n    var calendarList = args.calendarList,\n        numTiles = args.numTiles,\n        config = args.config;\n\n    var tileOverflowOffset = numTiles > 35 ? 1 : 0;\n    var overflowLength = 3 - tileOverflowOffset;\n    var multiEventPositions = [];\n    var difference = 0;\n\n    calendarList.map(function (eventArray, index) {\n        // A nono position is a spot in the eventArray that is reserved by a multi-day event in a previous tile.\n        // We need to keep track of these positions so that they are not overrided when sorting.\n        var nonoPositions = [];\n\n        // Loop through previous tile and store multi-day event positions so that we can keep track of them when\n        // determining the order of placeholder events.\n        if (index !== 0) {\n            calendarList[index - 1].map(function (previousEvent, previousArrayIndex) {\n                var _parseEvent = parseEvent(previousEvent, args, config),\n                    parsedDay = _parseEvent.parsedDay,\n                    parsedEnd = _parseEvent.parsedEnd;\n\n                if (previousEvent.type === _strings.MULTI_DAY_TYPE) {\n                    difference = parsedEnd - parsedDay;\n                    multiEventPositions = multiEventPositions.concat([[previousArrayIndex, difference, index - 1]]);\n                }\n\n                // If multi-day event is going to overflow, show that event continues over multiple days in overflow count.\n                if (calendarList[index - 1].length >= overflowLength) {\n                    if (previousEvent.type === _strings.MULTI_DAY_TYPE && calendarList[index - 1].indexOf(previousEvent) >= 3 - tileOverflowOffset) {\n                        for (var z = index - 1; z < index - 1 + (parsedEnd - parsedDay); z++) {\n                            if (z < numTiles && calendarList.length === overflowLength) {\n                                calendarList[z].length = calendarList[z].length + 1;\n                            }\n                        }\n                    }\n                }\n\n                return 0; // Get rid of warning\n            });\n        }\n\n        // If we have navigated through one row, reset multiEventPositions.\n        if (_strings.wrappingTiles.includes(index - 1)) {\n            multiEventPositions = [];\n            return 0;\n        }\n\n        // NoNo positions\n        multiEventPositions.map(function (position) {\n            if (Math.abs(index + 1 - position[1]) <= position[2]) {\n                nonoPositions.push(position[0]);\n            }\n            return 0;\n        });\n\n        eventArray.map(function (event, arrayIndex) {\n            if (event.type !== _strings.PLACEHOLDER_TYPE && nonoPositions.includes(arrayIndex)) {\n\n                // Search for position to swap.\n                for (var z = 0; z < calendarList[index].length; z++) {\n                    if (calendarList[index][z].type === _strings.PLACEHOLDER_TYPE && !nonoPositions.includes(z) && z !== arrayIndex) {\n                        var temp = calendarList[index][z];\n                        calendarList[index][z] = calendarList[index][arrayIndex];\n                        calendarList[index][arrayIndex] = temp;\n                    }\n                }\n            }\n            return 0;\n        });\n\n        // Reorder tile so that placeholders are in the same array position as their multi-day event parents.\n\n\n        return 0; // Get rid of warning\n    });\n};\n\nvar determineIndex = function determineIndex(parsedDay, args) {\n    var parsedMonth = args.parsedMonth,\n        month = args.month,\n        offset = args.offset,\n        numDaysInLastMonth = args.numDaysInLastMonth,\n        numDays = args.numDays;\n\n    switch (true) {\n        // Event belongs to 'this' month\n        case parsedMonth === month:\n            return parsedDay + offset - 1;\n\n        // Event belongs to previous month\n        case parsedMonth === (month - 1 >= 1 ? month - 1 : 12):\n            return parsedDay - numDaysInLastMonth + offset - 1;\n\n        // Event belongs to next month\n        default:\n            return numDays + parsedDay + offset - 1;\n    }\n};\n\nvar wrapLongEvent = function wrapLongEvent(event, ranOnce, calendarList, parts, i, config) {\n    var parsedDay = parts.parsedDay,\n        parsedEnd = parts.parsedEnd,\n        offset = parts.offset,\n        numTiles = parts.numTiles,\n        month = parts.month,\n        numDaysInLastMonth = parts.numDaysInLastMonth,\n        numDays = parts.numDays;\n\n\n    var endMonth = (0, _moment2.default)(event.end).month() + 1;\n\n    var startMonth = (0, _moment2.default)(event.start).month() + 1;\n\n    var start = 0,\n        end = 0;\n\n    start = determineIndex(parsedDay, { parsedMonth: startMonth, month: month, offset: offset, numDays: numDays, numDaysInLastMonth: numDaysInLastMonth });\n    end = determineIndex(parsedEnd, { parsedMonth: startMonth, month: month, offset: offset, numDays: numDays, numDaysInLastMonth: numDaysInLastMonth });\n\n    _strings.wrappingTiles.map(function (tileNum) {\n\n        if (start < tileNum + 1 && end > tileNum + 1 && i !== numTiles - 1 && !ranOnce && tileNum !== numTiles - 1) {\n\n            // If a multi-day event takes place over one of the wrapping tiles, it will need to be\n            // split into two events to prevent styles from overflowing past calendar border.\n            // e.g. 2019-05-19 - 2019-05-22 -> 2019-05-19 - 2019-05-20 && 2019-05-21 - 2019-05-22 where day 20 is on the edge\n            var original = calendarList[i].shift();\n\n            // Create deep copies. Fairly slow, but easiest way to make a deep copy since JS does not\n            // natively support deep copies.\n            var firstEvent = JSON.parse(JSON.stringify(original));\n            var secondEvent = JSON.parse(JSON.stringify(original));\n\n            var firstEnd = (0, _moment2.default)(firstEvent.end);\n\n            if (firstEnd.month() !== month) {\n                firstEnd.set('month', month - 1);\n            }\n\n            firstEnd.set('date', tileNum - offset + 2);\n\n            firstEvent.end = firstEnd.format(config.dateFormat);\n\n            calendarList[i].unshift(firstEvent);\n\n            var secondStart = (0, _moment2.default)(secondEvent.start);\n\n            if (secondStart.month() !== month) {\n                secondStart.set('month', month - 1);\n            }\n\n            secondStart.set('date', tileNum - offset + 2);\n\n            secondEvent.start = secondStart.format(config.dateFormat);\n\n            var newParts = {\n                parsedDay: tileNum - offset + 2,\n                parsedEnd: startMonth !== endMonth ? parsedEnd - numDays : parsedEnd,\n                numTiles: numTiles,\n                offset: offset,\n                month: month\n            };\n\n            if (calendarList[tileNum + 1]) {\n                calendarList[tileNum + 1].unshift(secondEvent);\n            }\n\n            wrapLongEvent(secondEvent, ranOnce, calendarList, newParts, tileNum + 1, event, config);\n\n            ranOnce = true;\n        }\n        return 0; // Get rid of warning\n    });\n};\n\nvar computeDifferences = function computeDifferences(firstDateCreated, secondDateCreated, firstEvent, secondEvent, args) {\n    var firstDateStart = args.firstDateStart,\n        firstDateEnd = args.firstDateEnd,\n        secondDateStart = args.secondDateStart,\n        secondDateEnd = args.secondDateEnd,\n        month = args.month,\n        numDaysInMonth = args.numDaysInMonth;\n\n    var numDays = numDaysInMonth[month - 1];\n\n    switch (true) {\n        // sort single day events by the date they were created\n        case firstDateStart.date() === firstDateEnd.date() - 1 && secondDateStart.date() === secondDateEnd.date() - 1:\n            return secondDateCreated.diff(firstDateCreated);\n\n        case firstDateStart.date() === firstDateEnd.date() - 1:\n            return -1;\n\n        case secondDateStart.date() === secondDateEnd.date() - 1:\n            return 1;\n\n        case firstDateStart.month() !== firstDateEnd.month():\n            return Math.abs(numDays - firstDateStart.date() - firstDateEnd.date()) - Math.abs(secondDateStart.date() - secondDateEnd.date());\n\n        case secondDateStart.month() !== secondDateEnd.month():\n            return Math.abs(firstDateStart.date() - firstDateEnd.date()) - Math.abs(numDays - secondDateStart.date() - secondDateEnd.date());\n\n        default:\n            return Math.abs(firstDateStart.date() - firstDateEnd.date()) - Math.abs(secondDateStart.date() - secondDateEnd.date()) === 0 ? secondDateCreated.diff(firstDateCreated) : Math.abs(firstDateStart.date() - firstDateEnd.date()) - Math.abs(secondDateStart.date() - secondDateEnd.date());\n\n    }\n};\n\nvar parseConfig = function parseConfig(config) {\n\n    for (var key in _strings.defaultConfig) {\n        if (!config.hasOwnProperty(key)) {\n            config[key] = _strings.defaultConfig[key];\n        }\n    }\n};\n\nexports.parseEvent = parseEvent;\nexports.reorderEvents = reorderEvents;\nexports.parseConfig = parseConfig;\nexports.wrapLongEvent = wrapLongEvent;\nexports.computeDifferences = computeDifferences;\n"]},"metadata":{},"sourceType":"script"}