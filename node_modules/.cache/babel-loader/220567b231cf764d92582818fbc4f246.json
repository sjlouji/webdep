{"ast":null,"code":"const objMap = ['years', 'months', 'days', 'hours', 'minutes', 'seconds'];\nconst numbers = '\\\\d+(?:[\\\\.,]\\\\d{0,3})?';\nconst datePattern = `(${numbers}Y)?(${numbers}M)?(${numbers}D)?`;\nconst timePattern = `T(${numbers}H)?(${numbers}M)?(${numbers}S)?`;\nconst pattern = new RegExp(`P(?:${datePattern}(?:${timePattern})?)`);\nexport function parseISO8601TimePattern(durationString) {\n  // https://github.com/tolu/ISO8601-duration/blob/master/src/index.js\n  return durationString.match(pattern).slice(1).reduce((prev, next, idx) => {\n    prev[objMap[idx]] = parseFloat(next) || 0;\n    return prev;\n  }, {});\n}\nexport function getPublishedAtDateString(iso8601DateString) {\n  if (!iso8601DateString) {\n    return '';\n  }\n\n  const date = new Date(Date.parse(iso8601DateString));\n  return date.toDateString();\n}\nexport function getVideoDurationString(iso8601DurationString) {\n  if (!iso8601DurationString || iso8601DurationString === '') {\n    return '';\n  } // new Date(Date.parse(...)) doesn't work here\n  // therefore we are using our regex approach\n\n\n  let {\n    days,\n    hours,\n    minutes,\n    seconds\n  } = parseISO8601TimePattern(iso8601DurationString);\n  let secondsString = seconds.toString();\n  let minutesString = minutes.toString();\n  let accumulatedHours = days * 24 + hours;\n\n  if (seconds < 10) {\n    secondsString = seconds.toString().padStart(2, '0');\n  }\n\n  if (minutes < 10 && hours !== 0) {\n    minutesString = minutesString.toString().padStart(2, '0');\n  }\n\n  if (!accumulatedHours) {\n    return [minutesString, secondsString].join(':');\n  } else {\n    return [accumulatedHours, minutesString, secondsString].join(':');\n  }\n}","map":{"version":3,"sources":["/Users/joan/Documents/Drive/Projects/punithargal.org/api/frontend/src/services/date/date-format.js"],"names":["objMap","numbers","datePattern","timePattern","pattern","RegExp","parseISO8601TimePattern","durationString","match","slice","reduce","prev","next","idx","parseFloat","getPublishedAtDateString","iso8601DateString","date","Date","parse","toDateString","getVideoDurationString","iso8601DurationString","days","hours","minutes","seconds","secondsString","toString","minutesString","accumulatedHours","padStart","join"],"mappings":"AAAA,MAAMA,MAAM,GAAG,CAAC,OAAD,EAAU,QAAV,EAAmB,MAAnB,EAA2B,OAA3B,EAAoC,SAApC,EAA+C,SAA/C,CAAf;AACA,MAAMC,OAAO,GAAG,yBAAhB;AACA,MAAMC,WAAW,GAAI,IAAGD,OAAQ,OAAMA,OAAQ,OAAMA,OAAQ,KAA5D;AACA,MAAME,WAAW,GAAI,KAAIF,OAAQ,OAAMA,OAAQ,OAAMA,OAAQ,KAA7D;AACA,MAAMG,OAAO,GAAG,IAAIC,MAAJ,CAAY,OAAMH,WAAY,MAAKC,WAAY,KAA/C,CAAhB;AAEA,OAAO,SAASG,uBAAT,CAAiCC,cAAjC,EAAiD;AACtD;AACA,SAAOA,cAAc,CAACC,KAAf,CAAqBJ,OAArB,EAA8BK,KAA9B,CAAoC,CAApC,EAAuCC,MAAvC,CAA8C,CAACC,IAAD,EAAOC,IAAP,EAAaC,GAAb,KAAqB;AACxEF,IAAAA,IAAI,CAACX,MAAM,CAACa,GAAD,CAAP,CAAJ,GAAoBC,UAAU,CAACF,IAAD,CAAV,IAAoB,CAAxC;AACA,WAAOD,IAAP;AACD,GAHM,EAGJ,EAHI,CAAP;AAID;AAED,OAAO,SAASI,wBAAT,CAAkCC,iBAAlC,EAAqD;AAC1D,MAAI,CAACA,iBAAL,EAAwB;AACtB,WAAO,EAAP;AACD;;AACD,QAAMC,IAAI,GAAG,IAAIC,IAAJ,CAASA,IAAI,CAACC,KAAL,CAAWH,iBAAX,CAAT,CAAb;AACA,SAAOC,IAAI,CAACG,YAAL,EAAP;AACD;AAED,OAAO,SAASC,sBAAT,CAAgCC,qBAAhC,EAAuD;AAC5D,MAAI,CAACA,qBAAD,IAA0BA,qBAAqB,KAAK,EAAxD,EAA4D;AAC1D,WAAO,EAAP;AACD,GAH2D,CAK5D;AACA;;;AACA,MAAI;AAACC,IAAAA,IAAD;AAAOC,IAAAA,KAAP;AAAcC,IAAAA,OAAd;AAAuBC,IAAAA;AAAvB,MAAkCpB,uBAAuB,CAACgB,qBAAD,CAA7D;AAEA,MAAIK,aAAa,GAAGD,OAAO,CAACE,QAAR,EAApB;AACA,MAAIC,aAAa,GAAGJ,OAAO,CAACG,QAAR,EAApB;AACA,MAAIE,gBAAgB,GAAGP,IAAI,GAAG,EAAP,GAAYC,KAAnC;;AAEA,MAAIE,OAAO,GAAG,EAAd,EAAkB;AAChBC,IAAAA,aAAa,GAAGD,OAAO,CAACE,QAAR,GAAmBG,QAAnB,CAA4B,CAA5B,EAA+B,GAA/B,CAAhB;AACD;;AACD,MAAIN,OAAO,GAAG,EAAV,IAAgBD,KAAK,KAAK,CAA9B,EAAiC;AAC/BK,IAAAA,aAAa,GAAGA,aAAa,CAACD,QAAd,GAAyBG,QAAzB,CAAkC,CAAlC,EAAqC,GAArC,CAAhB;AACD;;AACD,MAAI,CAACD,gBAAL,EAAuB;AACrB,WAAO,CAACD,aAAD,EAAgBF,aAAhB,EAA+BK,IAA/B,CAAoC,GAApC,CAAP;AACD,GAFD,MAEO;AACL,WAAO,CAACF,gBAAD,EAAmBD,aAAnB,EAAkCF,aAAlC,EAAiDK,IAAjD,CAAsD,GAAtD,CAAP;AACD;AACF","sourcesContent":["const objMap = ['years', 'months','days', 'hours', 'minutes', 'seconds'];\nconst numbers = '\\\\d+(?:[\\\\.,]\\\\d{0,3})?';\nconst datePattern = `(${numbers}Y)?(${numbers}M)?(${numbers}D)?`;\nconst timePattern = `T(${numbers}H)?(${numbers}M)?(${numbers}S)?`;\nconst pattern = new RegExp(`P(?:${datePattern}(?:${timePattern})?)`);\n\nexport function parseISO8601TimePattern(durationString) {\n  // https://github.com/tolu/ISO8601-duration/blob/master/src/index.js\n  return durationString.match(pattern).slice(1).reduce((prev, next, idx) => {\n    prev[objMap[idx]] = parseFloat(next) || 0;\n    return prev\n  }, {});\n}\n\nexport function getPublishedAtDateString(iso8601DateString) {\n  if (!iso8601DateString) {\n    return '';\n  }\n  const date = new Date(Date.parse(iso8601DateString));\n  return date.toDateString();\n}\n\nexport function getVideoDurationString(iso8601DurationString) {\n  if (!iso8601DurationString || iso8601DurationString === '') {\n    return '';\n  }\n\n  // new Date(Date.parse(...)) doesn't work here\n  // therefore we are using our regex approach\n  let {days, hours, minutes, seconds} = parseISO8601TimePattern(iso8601DurationString);\n\n  let secondsString = seconds.toString();\n  let minutesString = minutes.toString();\n  let accumulatedHours = days * 24 + hours;\n\n  if (seconds < 10) {\n    secondsString = seconds.toString().padStart(2, '0');\n  }\n  if (minutes < 10 && hours !== 0) {\n    minutesString = minutesString.toString().padStart(2, '0');\n  }\n  if (!accumulatedHours) {\n    return [minutesString, secondsString].join(':');\n  } else {\n    return [accumulatedHours, minutesString, secondsString].join(':');\n  }\n}\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}